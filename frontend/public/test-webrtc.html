<!DOCTYPE html>
<html>
<head>
    <title>WebRTCæµ‹è¯• - ç‹¬ç«‹é¡µé¢</title>
    <style>
        body { font-family: Arial; padding: 20px; background: #f5f5f5; }
        video { width: 640px; height: 480px; background: black; border: 2px solid #333; }
        button { padding: 10px 20px; margin: 5px; font-size: 16px; cursor: pointer; }
        .success { color: green; }
        .error { color: red; }
        #log { background: white; padding: 10px; margin-top: 10px; border: 1px solid #ccc; max-height: 300px; overflow-y: auto; }
    </style>
</head>
<body>
    <h1>ğŸ¥ WebRTC Avatar è¿æ¥æµ‹è¯•</h1>
    <video id="video" autoplay playsinline></video>
    <br>
    <button onclick="testConnection()">ğŸ”Œ æµ‹è¯•è¿æ¥</button>
    <button onclick="stopConnection()">â¹ æ–­å¼€</button>
    <div id="status"></div>
    <div id="log"></div>
    
    <script>
        let pc = null;
        const video = document.getElementById('video');
        const status = document.getElementById('status');
        const logDiv = document.getElementById('log');
        
        function log(msg, isError = false) {
            const time = new Date().toLocaleTimeString();
            const p = document.createElement('p');
            p.textContent = `[${time}] ${msg}`;
            p.className = isError ? 'error' : 'success';
            logDiv.appendChild(p);
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        async function testConnection() {
            try {
                status.innerHTML = 'â³ æ­£åœ¨è¿æ¥...';
                log('å¼€å§‹WebRTCè¿æ¥æµ‹è¯•');
                
                const config = {
                    sdpSemantics: 'unified-plan',
                    iceServers: [{ urls: ['stun:stun.l.google.com:19302'] }]
                };
                
                pc = new RTCPeerConnection(config);
                log('åˆ›å»ºRTCPeerConnection');
                
                pc.addTransceiver('video', { direction: 'recvonly' });
                pc.addTransceiver('audio', { direction: 'recvonly' });
                log('æ·»åŠ videoå’Œaudio transceiver');
                
                pc.addEventListener('track', (evt) => {
                    log(`æ”¶åˆ°${evt.track.kind} track`);
                    if (evt.track.kind === 'video') {
                        video.srcObject = evt.streams[0];
                    }
                });
                
                await pc.setLocalDescription(await pc.createOffer());
                log('åˆ›å»ºå¹¶è®¾ç½®æœ¬åœ°SDP offer');
                
                await new Promise((resolve) => {
                    if (pc.iceGatheringState === 'complete') {
                        resolve();
                    } else {
                        pc.addEventListener('icegatheringstatechange', () => {
                            if (pc.iceGatheringState === 'complete') {
                                resolve();
                            }
                        });
                    }
                });
                log('ICEå€™é€‰æ”¶é›†å®Œæˆ');
                
                const offer = pc.localDescription;
                const url = `http://${window.location.hostname}:8615/offer`;
                log(`å‘é€offeråˆ°: ${url}`);
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sdp: offer.sdp, type: offer.type })
                });
                
                log(`æœåŠ¡å™¨å“åº”: ${response.status} ${response.statusText}`);
                
                if (!response.ok) {
                    throw new Error(`æœåŠ¡å™¨é”™è¯¯: ${response.status} ${response.statusText}`);
                }
                
                const answer = await response.json();
                log(`æ”¶åˆ°answerï¼ŒSessionID: ${answer.sessionid}`);
                
                await pc.setRemoteDescription(answer);
                log('è®¾ç½®è¿œç¨‹SDP answerå®Œæˆ');
                
                status.innerHTML = `âœ… è¿æ¥æˆåŠŸï¼SessionID: ${answer.sessionid}`;
                log('WebRTCè¿æ¥å»ºç«‹æˆåŠŸï¼');
                
            } catch (error) {
                status.innerHTML = `âŒ é”™è¯¯: ${error.message}`;
                log(`è¿æ¥å¤±è´¥: ${error.message}`, true);
                console.error('è¯¦ç»†é”™è¯¯:', error);
            }
        }
        
        function stopConnection() {
            if (pc) {
                pc.close();
                pc = null;
                video.srcObject = null;
                status.innerHTML = 'â¹ å·²æ–­å¼€';
                log('è¿æ¥å·²æ–­å¼€');
            }
        }
        
        // é¡µé¢åŠ è½½æ—¶æ˜¾ç¤ºé…ç½®
        window.onload = () => {
            const hostname = window.location.hostname;
            log(`å½“å‰hostname: ${hostname}`);
            log(`WebRTCæœåŠ¡åœ°å€: http://${hostname}:8615`);
            log('è¯·å…ˆç¡®ä¿å·²é€‰æ‹©Avatarå¹¶ç­‰å¾…åˆ‡æ¢å®Œæˆ');
        };
    </script>
</body>
</html>
