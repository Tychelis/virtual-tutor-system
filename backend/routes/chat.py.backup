import os
import sys
from flask import Blueprint, request, jsonify, current_app, Response
from flask_jwt_extended import jwt_required, get_jwt_identity
from werkzeug.utils import secure_filename
from utils.token_utils import token_in_redis_required
from utils.refresh_token import refresh_token_and_redis
from utils.refresh_redis import refresh_redis_only
import requests
from models.user import User, db
from services.redis_client import redis_client
from models.chat import Session, Message
from datetime import datetime, timedelta
import json
import re

# Blueprint for chat-related routes
chat_bp = Blueprint("chat", __name__)

UPLOAD_FOLDER = "uploads"
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

# Allowed file extensions for uploads
ALLOWED_IMAGE = {"png", "jpg", "jpeg"}
ALLOWED_AUDIO = {"wav", "mp3", "m4a"}
ALLOWED_DOCS = {"pdf", "txt", "docx"}


def allowed_file(filename, allowed_exts):
    """Check if a file has an allowed extension."""
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in allowed_exts


@chat_bp.route("/chat", methods=["POST"])
@jwt_required()
@token_in_redis_required
@refresh_redis_only
def chat():
    """Send user message to LLM service, stream response, and store in DB."""
    response_data = {}

    user_email = get_jwt_identity()
    user = User.query.filter_by(email=user_email).first()
    if not user:
        return jsonify(msg="User not found"), 404

    # Retrieve RTC session ID from Redis (default to 1 if invalid)
    session_bytes = redis_client.get(f"sessionid:{user.email}")
    try:
        session_id_safe = int(session_bytes)
    except (TypeError, ValueError):
        session_id_safe = 1
    response_data["rtc_session_id"] = session_id_safe

    # Find or create chat session
    session_id = request.form.get("session_id")
    if session_id:
        session = Session.query.filter_by(id=session_id, user_id=user.id).first()
        if not session:
            return jsonify({"msg": "Session not found"}), 404
    else:
        cutoff = datetime.utcnow() - timedelta(minutes=30)
        session = (
            Session.query
            .filter_by(user_id=user.id)
            .filter(Session.updated_at >= cutoff)
            .order_by(Session.updated_at.desc())
            .first()
        )
        if not session:
            session = Session(user_id=user.id, title="New Chat")
            db.session.add(session)
            db.session.commit()

    # Process text input
    text = request.form.get("message")
    if text:
        response_data["text_input"] = text
        output_segments = []

        # Stream LLM response
        try:
            with requests.post(
                url="http://localhost:8610/chat/stream",
                json={"input": text, "session_id": session.id, "user_id": user.id},
                stream=True,
                timeout=60,
            ) as ask_response:

                ask_response.raise_for_status()

                buffer = ""
                for line in ask_response.iter_lines(decode_unicode=True):
                    if line and line.startswith("data:"):
                        chunk_data = json.loads(line.replace("data: ", ""))
                        chunk = chunk_data.get("chunk", "")
                        buffer += chunk

                        # Final chunk
                        if chunk_data.get("status") == "finished":
                            if buffer.strip():
                                forward_payload = {
                                    "sessionid": session_id_safe,
                                    "text": buffer,
                                    "type": "echo",
                                }
                                try:
                                    requests.post("http://localhost:8615/human", json=forward_payload, timeout=10)
                                except Exception as e:
                                    print(f"[WARN] Final forward failed: {e}")
                                output_segments.append(buffer)
                            break

                        # Forward intermediate output to video model
                        if buffer.endswith((".", "!", "?", "ã€‚")) or len(buffer.split()) >= 15:
                            forward_payload = {
                                "sessionid": session_id_safe,
                                "text": buffer,
                                "type": "echo",
                            }
                            try:
                                requests.post("http://localhost:8615/human", json=forward_payload, timeout=10)
                            except Exception as e:
                                print(f"[WARN] Forward to video model failed: {e}")
                            output_segments.append(buffer)
                            buffer = ""

            response_data["text_output"] = " ".join(output_segments)

        except Exception as e:
            response_data["text_output"] = " ".join(output_segments) + f" [Error: {e}]"

        # Store user and assistant messages in DB
        db.session.add_all([
            Message(session_id=session.id, role="user", content=text),
            Message(session_id=session.id, role="assistant", content=response_data["text_output"])
        ])
        session.message_count += 2
        session.updated_at = datetime.utcnow()
        db.session.commit()

    return jsonify(response_data), 200


@chat_bp.route("/sessionid", methods=["POST"])
@jwt_required()
def receive_session_id():
    """Save WebRTC session ID in Redis for current user."""
    data = request.get_json()
    session_id = data.get("sessionid")
    if not session_id:
        return "No session ID provided", 400

    user_email = get_jwt_identity()
    user = User.query.filter_by(email=user_email).first()
    if not user:
        return "User not found", 404

    ttl = current_app.config["REDIS_TOKEN_TTL_SECONDS"]
    redis_client.setex(f"sessionid:{user.email}", ttl, session_id)
    return '', 200


@chat_bp.route("/chat/new", methods=["POST"])
@jwt_required()
def create_session():
    """Create a new chat session."""
    user_email = get_jwt_identity()
    user = User.query.filter_by(email=user_email).first()

    data = request.get_json()
    title = data.get("title", "Untitled")

    new_session = Session(user_id=user.id, title=title)
    db.session.add(new_session)
    db.session.commit()

    return jsonify(session_id=new_session.id), 201


@chat_bp.route("/chat/history", methods=["GET"])
@jwt_required()
def list_sessions():
    """List all chat sessions for the current user."""
    user_email = get_jwt_identity()
    user = User.query.filter_by(email=user_email).first()
    sessions = Session.query.filter_by(user_id=user.id).order_by(Session.updated_at.desc()).all()
    return jsonify([
        {
            "id": s.id,
            "title": s.title,
            "created_at": s.created_at.isoformat(),
            "updated_at": s.updated_at.isoformat(),
            "message_count": s.message_count,
            "is_favorite": s.is_favorite
        } for s in sessions
    ]), 200


@chat_bp.route("/message/list", methods=["GET"])
@jwt_required()
def get_messages():
    """Retrieve messages from a specific chat session."""
    user_email = get_jwt_identity()
    session_id = request.args.get("session_id")
    user = User.query.filter_by(email=user_email).first()

    session = Session.query.filter_by(id=session_id, user_id=user.id).first()
    if not session:
        return jsonify({"msg": "Session not found or not authorized."}), 404

    messages = Message.query.filter_by(session_id=session.id).order_by(Message.created_at).all()
    return jsonify([
        {
            "role": m.role,
            "content": m.content,
            "created_at": m.created_at.isoformat(),
            "file_type": m.file_type,
            "file_path": m.file_path
        } for m in messages
    ]), 200


@chat_bp.route("/chat/<int:chat_id>/favorite", methods=["POST"])
@jwt_required()
def set_session_favorite(chat_id):
    """Set a chat session as favorite (only one favorite per user)."""
    data = request.get_json()
    is_favorite = data.get("is_favorite", True)

    user_email = get_jwt_identity()
    user = User.query.filter_by(email=user_email).first()
    if not user:
        return jsonify(msg="User not found"), 404

    session = Session.query.filter_by(id=chat_id, user_id=user.id).first()
    if not session:
        return jsonify(msg="Session not found"), 404

    if is_favorite:
        # Unset favorite for all other sessions
        Session.query.filter(
            Session.user_id == user.id,
            Session.id != chat_id
        ).update({Session.is_favorite: False}, synchronize_session=False)

    session.is_favorite = bool(is_favorite)
    db.session.commit()

    return jsonify({
        "msg": "Favorite status updated",
        "session_id": session.id,
        "is_favorite": session.is_favorite
    }), 200


@chat_bp.route("/chat/<int:chat_id>", methods=["DELETE"])
@jwt_required()
def delete_session(chat_id):
    """Delete a chat session."""
    user_email = get_jwt_identity()
    user = User.query.filter_by(email=user_email).first()
    if not user:
        return jsonify({"msg": "User not found"}), 404

    session = Session.query.filter_by(id=chat_id, user_id=user.id).first()
    if not session:
        return jsonify({"msg": "Session not found or not authorized"}), 404

    db.session.delete(session)
    db.session.commit()

    return jsonify({"msg": f"Session {chat_id} deleted"}), 200


@chat_bp.route("/llm/activate", methods=["POST"])
@jwt_required()
def forward_activate_model():
    """Forward model activation request to the LLM service."""
    current_user_email = get_jwt_identity()
    data = request.get_json()
    if not data or "model" not in data:
        return jsonify(msg="Missing 'model' in JSON payload"), 400

    try:
        response = requests.post(
            "http://localhost:8610/activate_model",
            json=data,
            timeout=15
        )

        try:
            response_data = response.json()
        except ValueError:
            return jsonify(msg="Invalid JSON response from model service", raw=response.text), 500

        if response.status_code == 200:
            return jsonify(response_data), 200
        else:
            return jsonify(msg="Model activation failed", detail=response_data), response.status_code

    except requests.RequestException as e:
        return jsonify(msg="Failed to connect to model service", error=str(e)), 500
